# Repo notes: atom/atom

## Overview
- README checks the basic boxes but lacks any path into the code base
  - test shields
  - mentions and links to Electron
  - product description, including links to community and code of conduct
  - links to documentation: Flight Manual and API Reference (see my notes)
  - installation prerequisites and OS steps
  - links to building instructions
  - license
- how to know the code?
  - existing docs don't directly answer that question
- goals of this doc:
  - break down and understand the codebase from a wide view
  - trace a beginning path through the code to gain that understanding

## Basic Branching
- `apm` for Atom Package Manager
  - just an install folder for APM: https://github.com/atom/apm
  - most use cases covered by APM command line tool
  - API info: https://atom.io/docs/api/v1.29.0/PackageManager
  - Flight Manual: https://flight-manual.atom.io/atom-server-side-apis/sections/atom-package-server-api/
  - an [example of how Atom uses apm](https://github.com/atom/settings-view/blob/master/lib/package-manager.coffee)
- `benchmark` for a benchmark runner and large file / long line tests
- `docs` for building documentation
  - focused on platform-specific instructions for building Atom from source
  - this was moved to the Flight Manual
  - `./focus` contains a doc [sharing current plans](https://github.com/atom/atom/tree/master/docs/focus)
- `dot-atom` contains the files and directories that install to `.atom`
  - including the custom stylesheet and keymap files
  - including the custom packages directory
- `exports` requires and exports objects
  - requires and exports a bunch of src objects that all seem to deal with file and buffer load/events
    - including Task and TextEditor when not a child node process (meaning when process type is `'renderer'`)
  - also contains a handful of Electron API shims using [grim.deprecate](https://github.com/atom/grim/blob/master/src/grim.coffee)
- `keymaps`
  - cson keybinding maps for various platforms
  - `base.cson` has selectors for `atom-text-editor` and many `body` default to native
  - movement, selection and many other bindings for `darwin`, `linux`, `win32`
- `menus`
  - three files containing array of menu items for different platforms
  - objects contain a `label` and `submenu` arrays of objects with `label` and `command`
- `resources`
  - png app icons
  - shell script, js and apm shell and command scripts for `win` installation
  - long bundle info plist for `mac`
  - debian and redhat package for `linux`
- `script`
  - a variety of scripts for building Atom
  - linter scripts
  - version and platform sensitive installation, cleaning, transpiling
  - `vsts` subfolder
    - contains its own README
    - scripts for automating Atom releases
    - `yml` files for configuring releases
    - tasks for handling release branch on different platforms
    - uses Visual Studio Team Services
      - [multi-phase jobs](https://github.com/Microsoft/vsts-agent/blob/master/docs/preview/yamlgettingstarted-jobs.md)
      - generate Atom installation packages on all three platforms
      - publish new release on successful build
    - Atom Nightly packages published to GitHub and atom.io
    - version release numbers calculated by `generate-version.js`
      - nightly release number incremented after comparing base version against `package.json`
    - phase templates build Atom simultaneously across platforms
    - successful build release artifacts uploaded to S3 bucket
- `spec`
  - quite a large directory with many CoffeeScript and JS `-spec` files
  - Jasmine `describe` tests
    - run for Atom environment, paths, clipboard, installation, grammar registry, style manager and much more
    - the project settings `config` spec is a long, representative example: https://github.com/atom/atom/blob/master/spec/config-spec.js
  - `./helpers` directory contains a random line builder and a very long lexicon
  - `./fixtures` contains samples with extreme formatting, example packages, sample themes
  - `./main-process` contains the application test and command line test
- `src`
  - `./main-process` subdirectory contains application start, menu, win updater and more
    - the short `main.js` is where the start path is built
    - `parse-command-line.js` breaks down cli args and returns object with all the process info
    - `start.js` is called from `main`
      - runs the command line parser and stores the resulting `args`
      - sets up `app.on` events for opening files, launching and ready
      - requires `./main-process/atom-application` and runs `.open` with `args`
      - defines a `getConfig` function to read the config file
  - the rest of the directory is many `.js` and `.coffee` files
    - class exports for many of the objects documented in the API
      - for example, [Package](https://atom.io/docs/api/v1.29.0/Package) relates to `package.js`
      - that example defines `onDidDeactivate (callback) { ... }` mentioned in the API docs
      - others include everything from `gutter` to `pane` to `cursor` to global `config-file`
    - `grammar-registry` is an example with many requires, complex class methods, much to think through
    - some API doc classes come from other sources imported into these `src` files
      - like `Emitter` from `event-kit`
        - for example, the `package.js` mentioned above requires and instantiates `Emitter`, then `onDidDeactivate` returns `emitter.on()` event with your callback
      - or like `Disposable` and `CompositeDisposable` from `event-kit`
    - some scripts provide other functionality
      - like how `crash-reporter-start` requires and starts CrashReporter from `electron`
      - or how `babel` creates a babel version and compiles source using babel
- `static`
  - `.less` files for editor, cursors, docks, syntax and much more
  - stylesheet fallback variables
  - basic html template `index.html`
  - window load and setup script in `index.js`
  - and the octocat spinner!
- `vendor`
  - Jasmine tests for JS and JQuery
  - on second glance, these are not tests but the testing framework
  - see tests under `spec`
- root files
  - `.gitattributes` for defining line endings on `spec/fixtures` files
  - support/appinfo files for appveyer, coffeelinter, Python versioning, style linter, Docker
  - package and package locks for node
  - Travis config yaml file
  - `LICENSE` copyrights software to GitHub, permissively allowing as-is use
  - user submission templates
    - `ISSUE_TEMPLATE` defines checklist and format to use when submitting an issue
    - `PULL_REQUEST_TEMPLATE` defines requirements and needed info when submitting a PR
  - `CHANGELOG` links to [Atom releases](https://atom.io/releases)
  - `README` and `SUPPORT` provide documentation for getting into Atom
    - the readme focuses on installation
    - the support doc focuses on links into the documentation and community
  - `CODE_OF_CONDUCT` adapts the OSS [Contributor Covenant](https://www.contributor-covenant.org/)
  - `CONTRIBUTING` offers a detailed set of guidelines for contributing to Atom

## CONTRIBUTING.md in greater detail
- since the focus of my repo is on contributing, I'll outline this in detail
- Atom as part of the [Atom Organization](https://github.com/atom)
- contributor covenant as mentioned above
- issues are a [deluge](https://blog.atom.io/2016/04/19/managing-the-deluge-of-atom-issues.html) and are not for questions
- discussions happen at [discuss](https://discuss.atom.io/), which has a FAQ[FAQ](https://discuss.atom.io/c/faq)
- faster discussion happens in the [team chat](https://atom-slack.herokuapp.com/)
  - use the appropriate channel: `#atom`, `#electron`, `#packages`, `ui`
- background knowledge
  - Atom has over 200 repos, so know which implements which functionality
  - this helps so you know where to report bugs
  - modularity by intention
    - non-editor UI is almost always a separate package
    - even tree-view, find-and-replace, tabs and status-bar are packages
    - key difference: whether a package is bundled into default distribution
  - visit `Settings` and view `Packages` to see Core packages
    - Atom Core: `atom/atom`
      - text editor
      - associated functionality like indentation, wrapping, rendering, file system, installation and updating
      - this repo is good for giving feedback on API or proposing "overarching" features
    - stuff around the UI
      - like `tree-view`, `fuzzy-finder` (quick file opener), `find-and-replace`, `tabs`, `markdown-preview`, `settings-view`, ...
    - stuff around behavior and styling
      - like autocomplete, git, default UI and syntax themes
    - Atom Package Manager: `apm`
    - Feedback repo for website and `apm`'s package API: `atom.io`
  - note that issues arise from [community pacakges and themes](https://discuss.atom.io/t/i-have-a-question-about-a-specific-atom-community-package-where-is-the-best-place-to-ask-it/25581)
  - package naming conventions
    - syntax highlighting grammars: `language-[language-name]`
      - these can add more than grammars but shouldn't get too bulky
    - UI themes: `[theme-name]-ui`
      - these style stuff outside editor pane
    - syntax themes: `[theme-name]-syntax`
      - these style stuff inside editor pane
      - (me: wow, that's an easy distinction I wish the Flight Manual made)
    - coordinate themes that do both, like `one-dark-ui` and `one-dark-syntax`
    - atocomplete providers: `autocomplete-[autocompleted]`
      - an example might be `autocomplete-css`
  - design decisions
    - commitment to maintain a [decisions repo](https://github.com/atom/design-decisions)
    - this will include big decisions about how Atom is maintained and what can be supported
    - if decisions are not documented there, check the "discuss" link above
- ways to contribute
  - report a bug
    - point of having you follow these steps
      - maintainers and community can understand your report
      - maintainers and community can reproduce the behavior
      - maintainers and community can find related reports
    - general things to keep in mind as you report
      - [ ] be as detailed as you can
      - [ ] if there's a similar closed issue, include a link
      - [ ] stick to the [issue template](https://github.com/atom/atom/blob/master/ISSUE_TEMPLATE.md)
    - follow these steps _before_ submitting a report:
      - [ ] check if you can reproduce the problem in the latest Atom release
      - [ ] check if the problem shows up in safe mode
      - [ ] check if you can solve by changing package config
      - [ ] reread the [debugging guide](https://flight-manual.atom.io/hacking-atom/sections/debugging/) to see if you can fix it yourself
      - [ ] check the [FAQ](https://discuss.atom.io/c/faq)
      - [ ] figure out which repo this issue belongs in
      - [ ] search already [reported issues](https://github.com/search?q=+is%3Aissue+user%3Aatom) to see if you can just add a comment to an existing issue
    - follow these steps _when_ submitting a report:
      - [ ] understand that bugs are tracked as [GitHub issues](https://guides.github.com/features/issues/)
      - [ ] determine the correct Atom repo (mentioned above)
      - [ ] create an issue
      - [ ] fill out the template (linked above)
      - [ ] explain the problem with:
        - [ ] clear, descriptive title
        - [ ] exact steps to reproduce the issue (not _what_ you did but _how_: with a mouse or a shortcut? which one?)
        - [ ] specific examples for each step (links to files/projects, Markdown code block snippets)
        - [ ] observed behavior after these steps are taken
        - [ ] expected behavior and why it's expected
        - [ ] screenshots or [animated GIFs](https://www.cockos.com/licecap/) with Keybinding Resolver in view
        - [ ] crash reports with stack trace from the OS if issue crashes Atom
          - Mac `Console.app` under "User Diagnostic Reports"
          - include in a code block, attached file or link to gist
        - [ ] a [CPU profile caputure](https://flight-manual.atom.io/hacking-atom/sections/debugging/#diagnose-runtime-performance) for memory or performance issues
        - [ ] confirmation you ran in safe mode and used a different theme (or commented out styles) if Chrome dev tools show without being triggered
        - [ ] your prior actions if the problem wasn't triggered by specific actions
      - [ ] answer these questions to give more context:
        - [ ] Can the problem be reproduced in safe mode?
          - [ ] If so, can you reproduce it in an older Atom version?
        - [ ] Did the problem start recently?
        - [ ] Can you reproduce the problem reliably?
        - [ ] Does the problem happen for all files/projects or only some?
          - [ ] check if it's only for specific file types
          - [ ] check if it's only large files or files with long lines
          - [ ] check if it's only remote or local files
      - [ ] include config and environment info
        - [ ] your Atom version (`atom -v` or `Application: About` in the Command Palette)
        - [ ] your OS name and version
        - [ ] your VM if applicable (software and OS name/version for host and guest)
        - [ ] your Atom packages (`apm list --installed`)
        - [ ] your customized local config files (`config.cson`, `keymap.cson`, `snippets.cson`, `styles.less`)
          - ideally in a code block or a gist link
        - [ ] your monitor setup if using multiple monitors (have you tried only one?)
        - [ ] your keyboard layout (US, ...)
  - suggest enhancements
    - submit an "enhancement suggestion" for:
      - features for new functionality
      - minor improvements
    - follow these guidelines so
      - maintainers and community can understand your suggestion
      - maintainers and community can find related suggestions
    - general advice when considering creating one
      - check the pre-submitting steps below
      - include as many details as you can
      - refer to and use the [issue template](https://github.com/atom/atom/blob/master/ISSUE_TEMPLATE.md)
    - before submitting
      - [ ] review the [debugging guide](https://flight-manual.atom.io/hacking-atom/sections/debugging/) to make sure the enhancement doesn't already exist
      - [ ] make sure you're on the latest Atom version
      - [ ] check if you can get the behavior through core packages or config
      - [ ] check if you can get the behavior through registered Atom packages
      - [ ] figure out the relevant Atom repo
      - [ ] search [existing suggestions](https://github.com/search?q=+is%3Aissue+user%3Aatom) before opening a new one
    - while submitting
      - [ ] understand that enhancement suggestions are tracked through GitHub issues
      - [ ] create an issue on the relevant repo you determined above
      - [ ] fill out the issue with:
        - [ ] a clear title for identifying your suggestion
        - [ ] a detailed, step-by-step description
        - [ ] specific, demonstrable examples with Markdown code block snippets
        - [ ] a description of the current behavior vs what you expect instead
        - [ ] screenshots and animated GIFs to demonstrate steps and related parts of Atom
        - [ ] an explanation of the enhancement's usefulness to Atom users
          - [ ] including why this couldn't be a community package
        - [ ] a list of other text editors or apps with this enhancement
        - [ ] the version of Atom you're on (`atom -v` or Command Pallete `Application: About`)
        - [ ] the name and version of your OS
  - your first contribution
    - understand where to begin when contributing to Atom
      - search [beginner issues](https://github.com/search?utf8=%E2%9C%93&q=is%3Aopen+is%3Aissue+label%3Abeginner+label%3Ahelp-wanted+user%3Aatom+sort%3Acomments-desc)
      - search [help wanted issues](https://github.com/search?q=is%3Aopen+is%3Aissue+label%3Ahelp-wanted+user%3Aatom+sort%3Acomments-desc+-label%3Abeginner)
      - "help wanted" issues are more involved
      - issue lists are sorted by comment count (to operationalize the "impact a given change will have")
    - read through the Flight Manual for using Atom or developing packages
    - local development
      - core and packages support local development
      - the relevant Flight Manual sections are [Hacking on Atom Core](https://flight-manual.atom.io/hacking-atom/sections/hacking-on-atom-core/) and [Contributing to Official Atom Packages](https://flight-manual.atom.io/hacking-atom/sections/contributing-to-official-atom-packages/)
  - pull requests
    - refer to the [template](https://github.com/atom/atom/blob/master/PULL_REQUEST_TEMPLATE.md)
    - make sure the PR includes:
      - clear title but without the PR issue number
      - animated GIFs and screenshots
      - syntax and styling following the [JS](https://github.com/atom/atom/blob/master/CONTRIBUTING.md#javascript-styleguide) and [CS](https://github.com/atom/atom/blob/master/CONTRIBUTING.md#coffeescript-styleguide) guides
      - Jasmine specs in the `./spec` dir that have been run with `atom --test spec`
        - these tests should be "thoughtfully worded"
        - these tests should be "well structured"
      - follow the [documentation styleguide](https://github.com/atom/atom/blob/master/CONTRIBUTING.md#documentation-styleguide) for any added code
      - files that end in a newline
      - no platform dependent code
      - ordered requires: built in Node modules, built in Atom and Electron modules, local modules (with relative paths)
      - ordered class properties: class properties (`@` in CoffeeScript, `static` in JS), then instance methods/properties
- Styleguides
  - git commit messages
    - verbs in the present tense, imperative mood
    - first line length <= 72 characters
    - after first line reference specific issues and PRs
    - documentation changes: include `[ci skip]` in the title
    - begin with the [correct emoji](https://github.com/atom/atom/blob/master/CONTRIBUTING.md#git-commit-messages)
  - JS
    - stick to [Standard Style](https://standardjs.com/)
    - use object spread instead of `Object.assign()`
    - use inline exports instead of post-definition/instantiation exports
  - CS
    - default parameters without spaces around equals sign
    - spaces around operators otherwise
    - spaces after commas that aren't followed by newline
    - use parens when they make code clearer
    - use alphabetic instead of symbolic keywords: `is` over `==`
    - do not use spaces before closing curly brace or after opening curly brace
    - leave one whitespace line between method definitions
    - caps acronyms unless they are the first word: `getURI` but `uri`
    - copy arrays with `slice()`
    - use explicit `return`s in functions ending in `for`/`while` loops
      - do this when avoiding returning a collection
    - use `this` instead of standalone `@`: `return this` not `return @`
  - specs
    - use Jasmine specs in `./spec`
      - ensure they're "thoughtfully-worded, well-structured" tests
      - use `describe` statements for nouns or situations
      - use `it` statements for states or operation changes to state
    - consider [this simple example](https://github.com/atom/atom/blob/master/CONTRIBUTING.md#example)
  - documentation
    - use the [AtomDoc parser](https://github.com/atom/atomdoc)
    - use Markdown
    - reference classes and methods with this notation:
      - classes with `{ClassName}`
      - instance methods with `{ClassName::methodName}`
      - class methods with `{ClassName.methodName}`
- issue and PR labels
  - for issue types and issue states
    - enhancements: feature requests
    - bugs: reported (when likely) or confirmed bugs
      - needs-reproduction are likely bugs but need tested
    - questions and feedback from users
    - more-information-needed, needs-reproduction for more about reproduce steps
    - duplicate, blocked, invalid, wontfix, wrong-repo for issues with issues
    - help-wanted, beginner for community calls for contributors
    - package-ideas for new packages instead of extensions or core
  - for topic categories
    - os: windows, linux, mac
    - documentation, performance, security, ui
    - errors: uncaught-exception, crash
    - ui, api, git, network (remote files), encoding
  - atom/atom topic categories
    - editor text rendering (independent of language)
    - errors: from pathwatcher, from save, from open, build errrors
    - os: installer, auto-updater
    - deprecation help for packages removing deprecated API usage
  - PR labels
    - work in progress
    - needs review or under review
    - requires changes
    - needs testing

## src directory in greater detail
- flow:
  - `package.json` has a key `"main"` pointing to `src/main-process/main.js`
  - `package.json` has a `"standard"` key for `"snapshotResult"`
  - `src/main-process/main.js` checks for any `snapshotResult`
  - `main.js` builds a path to and calls `start.js`
  - `start.js` opens `atom-application.js`:
    - imports the electron app
    - imports a path
    - later in one method there's a same-dir import: Win `squirrel-update`, which in turn imports from `spawner`
    - defines a `start` function that:
      - adds exception and rejection handling listeners
      - parses the command line args
      - adds app open listeners for path and url
      - sets app path to user or test data
      - adds app ready listener to remove open listeners then open Atom app
        - path built from resource path + `src/main-process/atom-application.js`
    - (outside `start` are also win32 and user config file functions)
  - `atom-application` loads and juggles the app
    - imports `atom-window`, `application-menu`, `config-file`, other Atom stuff
    - imports `event-kit` disposables
    - imports electron pieces like `BrowserWindow`, `clipboard`, `screen`
    - beyond that the Atom app's class is defined including the open method (run from `start`)
    - see closer look at `atom-application.js` below
  - classes from other same-dir scripts are included in the Atom application
    - `atom-window`, `application-menu` `atom-update-manager`, `atom-protocol-handler`, `file-recovery-service`
    - see closer looks at specific `main-process` files below

## TODO learn more about:
- [X] socket files in `atom-application.js`
  - see beneath the file-by-file summaries for supporting stuff
- [X] Electron `app` questions & curiosities: how do these work? what's going on here?
  - `app.focus` gets run in `openWithOptions`
  - `app.quit` gets run for example in `removeWindow`
- [X] Electron IPC including `ipcMain` and `ipcHelpers`
  - [ ] ipcMain events, using sender to find browser window
  - [ ] `ipcHelpers.on` to add disposable listeners (`ipcMain` and `app` listeners)
    - difference between browser window and Atom window
- [X] how disposables dispose (`const Disposable = require('event-kit').Disposable` as in `src/ipc-helpers`)
  - this gets into `event-kit` (see more below)
- [X] leading semicolon in `atom-application` method `runTests`?
  - see example code lines below
```JavaScript
if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {
  ;({resourcePath} = this)
}
```
  - the syntax occurs in both `runTests` and `runBenchmarks` in `src/main-process/atom-application`
  - is this to end a previous statement? if so, which?
  - seen as a way to chain code safely (like for minifying) in [this question-answer](https://stackoverflow.com/questions/1873983/what-does-the-leading-semicolon-in-javascript-libraries-do)
  - the assignment is in parens
  - the semicolon could be for safely concatenating parens, but why are the parens there?
    - testing in node v11 with small script below
    - syntax error unexpected token `=` without the parens
    - so the parens clear up the parsing of an assignment statement following `{`
    - the addition or omission of `;` does not give different behavior or errors
  - the semicolon was included in the "decaffeinated" JS Atom app at [this commit](https://github.com/atom/atom/commit/043f183b1a3202e323d2c7f517cdcc4636be77ba#diff-63931220a4d57b726ca3d2edc445f371)
  - nothing similar in the previous `atom-application.coffee`
    - the if statement has minimal syntax: `if resourcePath isnt @resourcePath and not fs.existsSync(resourePath)`
    - it's a simple assignment `resourcePath = @resourcePath`
  - conjectured explanations
    - it may be a safeguard to ensure parens are properly concatenated
    - it may have been added on seeing the initial sequence `({` in an assignment statement
    - there may be or have been a relevant project or team style standard
      - (no such info retrieved on first search of repo or docs)
```JavaScript
this.resourcePath = 'asdf'
let resourcePath = '123'
let someScript
if (resourcePath !== this.resourcePath) {
  {resourcePath} = this   // surround with parens to prevent unexpected token error
}
```
- [ ] `ApplicationMenu` class defines method `translateTemplate` that iterates through template and sets keybindings and click executions
  - after assigning a template item's accelerator and click properties it checks and flags this:
```JavaScript
if (!/^application:/.test(item.command)) {
  item.metadata.windowSpecific = true
}
```
- [X] spec window comes up much
  - see `atom-window`: window that `handlesAtomCommands` is not spec and not web view focused
  - `.isSpec` is passed into Atom window constructor through `settings` object
  - `window.isSpec` is checked in `atom-application`
  - `this.isSpec` is checked throughout `atom-window`
  - this setting is set `true` when `new AtomWindow` created in `runTests`
  - when Electron app is ready `start.js` runs `AtomApplication.open` passing `args`
  - those `args` come from `parseCommandLine` (from `parse-command-line`) on `process.argv`
  - I still don't see where the `isSpec` is passed since instantiations that pass `settings` to Window pass things like boolean benchmark but not an `isSpec`
- [X] Atom protocol handler in `main-process/` imports Electron `protocol` and runs `protocol.registerFileProtocol`
  - first line is destructured assignment of `protocol` from `'electron'`
  - the `registerFileProtocol` call passes `'atom'` and callback
  - this Electron method is defined and set in `atom/browser/api/`
    - in `atom_api_protocol.cc` the method is mapped to `RegisterProtocol`
    - the `RegisterProtocol` method is defined in `atom_api_protocol.h`
      - take a `scheme` string pointer, a pointer to a `handler` and some args
      - basically do some browser thread work registering the protocol then running the callback
- [ ] where exactly in `atom-application` do we get into the code that's in main `src/`?

### atom-application.js
- requires `AtomWindow`, `ApplicationMenu`, `event-kit` Disposables, `EventEmitter`, ...
- requires multiple `electron` exports including `app`
- crucially exports a defined `AtomApplication` class inheriting from `EventEmitter`
  - comment notes it's a singleton entry point to the app
  - comment notes it holds global app state
  - starts by defining a static method `open`
    - if there's not an open socket file, create a socket path
    - instantiate and initialize `AtomApplication`
    - set up `net.connect` client to end connection and run `app.quit`
    - have client reinstantiate and reinitialize on `'error'`
  - then defines an `exit` method
    - this runs `app.exit`
  - next comes the constructor method
    - takes one `options` argument
    - empty `super` call
    - directly assign class variables and bind methods
    - assigned properties range from boolean `this.quitting` to `this.resourcePath`
    - many properties pulled from `options` like `options.socketPath` or `options.version`
    - run `initializeAtomHome`
    - join a config file path and assign a `this.configFile`
    - create and assign `this.config` object with a callback to save `this.configFile`
    - set `this.config` schema
    - set a new file recovery service, storage folder, auto update manager
    - create a `CompositeDisposable` and assign to `this.disposable`
    - run `this.handleEvents` ("Registers basic application commands" see below)
  - then defines an async `initialize` method
    - originally in constructor but moved out for testing "without booting up the world"
    - assign `global.atomApplication = this`
    - deprecated code for Mac OS to change `useCustomTitleBar` to `titleBar: custom`
    - instantiate and assign an application menu and protocol handler
    - start listening for new process arguments (see method below)
    - set up dock menu (see method below)
    - await and return result of `this.launch(options)`
  - then an async `destroy` method
    - close windows in promises and await all window close promises
    - run `this.disposable.dispose()`
  - then the `launch` method called at the end of `initialize` (construction)
    - promise watching for config file changes, add that to disposable, then add restart change listeners
    - create array of options for opening windows and determine if previous windows should reopen
    - run `this.openWithOptions` on each option in the array of options for windows to open
  - define `openWithOptions` (run from `this.launch`)
    - destructure paths, tests, mode, startup, window options from passed-in `options`
    - run `app.focus()` on the Electron app instance
    - branching checks for options
      - if it's a test, call `this.runTests` with relevant options
      - or a benchmark, call `this.runBenchmarks` with relevant options
      - or if there are `pathsToOpen`, run `this.openPaths` with options
      - or if there are `urlsToOpen`, run `this.openUrl` for each one
      - otherwise call and return `this.openPath` with relevant options
  - the `removeWindow` public method runs `this.windowStack.removeWindow`
    - quits the app if all windows are removed
  - the `addWindow` public method adds a window to the window stack
    - loaded listener for auto update manager to notify available updates
    - add listeners to window for focus, blur, closed (remove focus, blur)
  - `getAllWindows` returns the members of the window stack
  - `getLastFocusedWindow` runs window method returning the last focused window
    - takes optional boolean predicate, used for example for checking `window.isSpec`
    - the `WindowStack` class defines the called method, and by default sets null predicates to `win => true`
  - the method to listen for new launches of the Atom application
    - check for a socket path and delete the socket file
    - create a server with `net.createServer`
      - with a data listener to concatenate data chunks
      - with an end listener to `this.openWithOptions` on the concatenated, JSON parsed data
    - have the created server listen on the socket path
    - send errors to the console on server error
  - `deleteSocketFile` runs a filesystem unlink sync on the socket path, with non-ENOENT error handling
    - remember the socket path has been stored in `this.socketPath`
    - only run if it's not Windows and there is a socket path
  - the `handleEvents` method "[r]egisters basic application commands"
    - this is run at the end of `constructor`
    - define local `getLoadSettings` to check if using dev or safe mode
    - add a half dozen `this.on` listeners for running app new/open/quit tasks
    - add a half dozen `this.on` listeners for shell opening external links to docs, issues, ...
    - add update check and install listeners
    - add `this.on` listeners for app window sizing (many more for `darwin` than other OS)
    - add `this.openPathOnEvent` listeners for opening config, license, keymap and other Atom files
    - add config file listeners
      - `onDidChange` listener to set user config settings
      - `onDidError` listener for failed to read user settings
    - `this.disposable.add` for quite a few `ipcHelpers.on` event Disposables
      - starting with a long one for waiting to run `app.quit` until all windows unload and close
      - an `app` one for `will-quit` that kills all processes and deletes socket file
      - an `app` one for `open-file` that prevents default and opens a path passed to callback
      - an `app` one for `open-url` that prevents default and opens the passed-in url with dev and safe modes
      - an `app` one for `activate` that emits `application:new-window` if there are no visible windows
      - an `ipcMain` one for restarting the app
      - an `ipcMain` one for resolving `event.sender` URL proxy and sending `did-resolve-proxy` if `event.sender` is not destroyed
      - an `ipcMain` one for `did-change-history-manager`
        - checks if each window's `webContents` match `event.sender`
        - otherwise has the `webContents` send `did-change-history-manager`
      - an `ipcMain` one for opening a new render process (path in Atom window)
      - and many more `ipcMain` one for other events including:
        - updating the window
        - running package specs
        - running benchmarks
        - emitting a command
        - prompting for paths on `application:open` commands (including open file or folder)
        - prompting for path on picking folder
      - a number of `ipcHelpers.respondTo` events including:
        - running a browser window method with spread passed-in args
        - setting window size
        - setting window position
        - setting user settings (config file update)
        - centering/focusing/showing/hiding window
        - getting temporary window state
        - setting the `this.fileRecoveryService` did save or will save file path
      - even more `ipcHelpers.on` including ones that:
        - write to clipboard, to stdout, to stderr
        - add a recent document filename
        - execute code using `event.sender.devToolsWebContent.executeJavaScript`
        - get the `autoUpdateManager` state or its error
        - save the current window options when paths changed
    - and finally one more disposable to disable zoom on display change
  - `setupDocMenu` to build a Mac OS menu with a `'New Window'` label that emits `application:new-window`
  - `initializeAtomHome` to make sure the `.atom` config home path is synced
  - `sendCommand` to emit an Atom command with passed-in args to `focusedWindow` or first responder
  - `sendCommandToWindow` to emit command with args to `atomWindow`
  - `sendCommandToFirstResponder` to send actions to `Menu.sendActionToFirstResponder`
    - sent actions: cut, copy, paste, undo, redo, select-all
  - `openPathOnEvent` to create a `this.on` listener that opens path in focused window (or new if no focused window)
  - `windowForPaths` to find all windows that contain passed-in open paths
  - `atomWindowForEvent` to find browser window matching sender of passed-in ipcMain event
  - `atomWindowForBrowserWindow` to find window with passed-in browser window
  - `focusedWindow` to return the focused Atom window
  - `getWindowOffsetForCurrentPlatform` to return the Win or Mac OS window offset
  - `getDimensionsForNewWindow` to calculate non-maximized window dimensions
    - use methods for window focus, platform offset as well as window dimensions
  - `openPath` to run `this.openPaths` with a path and property options
    - note the destructured object arg with a default assignment
  - `openPaths` to open each passed-in path with the window and mode options
    - another destructured object arg with a default assignment
      - as above these are destructured window, mode, path properties
      - the comment explains each of the properties
    - parse paths and add to an array of locations to open with extra
    - determine if adding to open window otherwise set up an Atom window for path
    - set a browser window listener to kill open window once closed
  - `killAllProcesses` to get window wait sessions, kill each window process and delete wait session
  - `windowDidClosePathWithWaitSession` to remove a path from window sessions
    - get window wait sessions, delete passed-in path from remaining session paths
    - kill process if this completely empties session paths
  - `killProcess` to run `this._killProcess` with a passed-in `pid`
    - error handling to log if process kill failed and error is not `'ESRCH'`
  - async `saveCurrentWindowOptions` to save state for each app window
    - take a boolean `allowEmpty`
    - do not run if `this.quitting`
    - store all windows' directory paths in a `states` array, reverse the array
    - call and wait for `this.storageFolder.store` to store the app states in `application.json`
    - emit `application:did-save-state`
  - async `loadPreviosWindowOptions` to return an array of state objects with paths and modes
    - get those from `this.storageFolder.load` to load states from `application.json`
  - `openUrl` to parse URL for package name and run `openPackageUrlMain` with settings
    - if no package found run `openPackageUriHandler`
  - `openPackageUriHandler` to get or open window then open the passed-in `url`
    - either get an appropriate focused window and message it with `url`
    - or open and add new Atom window (with resolved initialization script) and message with `url`
  - `findPackageWithName` to find package metadata for package having passed-in `name`
  - `openPackageUrlMain` to resolve package path, initialization script and add a new window with path and options
  - `getPackageManager` to return `this.packages`
    - initialize a new `PackageManager` and assign to `this.packages` with config path, resource path, `devMode`
  - `runTests` load tests from `pathsToOpen` and run in new window
    - reset resource path to `this.resourcePath` if they don't match and there's no filesystem sync for it
    - set a timeout for exiting tests at time limit
    - resolve window initialization script (more hands-on with dir paths than window open methods above)
    - build array of test paths from resolved paths to open and exit process if this ends up empty
    - set options for modes and test runner paths
    - open and add a new window with all of the above options
  - `runBenchmarks` to run a test in a window
    - headless, resource path, paths to open, environment and where executed from as with `runTests`
    - unlike running tests takes no logfile or timeout but takes one test
    - same window initialization logic as in `runTests` but resolving `initialize-benchmark-window`
    - open and resolve benchmark paths and exit if there aren't any
    - open and add a new window with options (but unlike test no test runner paths)
  - `resolveTestRunnerPath` to find package root and resolve runner path with base and extensions
    - use `find-parent-dir` to sync package root path
    - sync and return path for test runner from package metadata
    - write out error and exit process if there's no package metadata test runner
    - if no root dir is assignable from test path `package.json` then run method to resolve legacy path
  - `resolveLegacyTestRunnerPath` to try to resolve the Jasmine spec runner from dev path
    - if this errs then use Jasmine spec path relative to `__dirname`
  - `parsePathToOpen` to break raw path into line and column starts, normalized path and return that info in object
  - `promptForPathToOpen` to open a dialog that calls `promptForPath` with callback for modes and paths to open
  - `promptForPath` to take fs type, callback and path
    - check type to store properties `'openFile'` or `'openDirectory'`
    - set parented or unparented dialog window based on platform
    - run `dialog.showOpenDialog` with parent window, options, callback
  - `promptForRestart` to run `dialog.showMessageBox` with restart prompt
    - pass focused browser window
    - pass object with properties for warning type, restart title, message and buttons
    - pass callback for restarting if response is `0`
  - `restart` to relaunch with same args and quit app
    - store modes, log file, socket path, user data dir flags as `args`
    - run `app.relaunch` with those args
    - run `app.quit`
  - `disableZoomOnDisplayChange` to keep window from "zooming the webframe"
    - create a callback that runs `window.disableZoom` on all windows
    - add `screen.on` listeners for `display-added` and `display-removed` that call the callback
    - return a `Disposable` with `screen.removeListener` for the two events with that callback
- a `WindowStack` class at the very bottom
  - constructor takes windows array and binds `this` to methods
  - `addWindow` to take a `window`, remove it from windows array and `unshift` it back in
  - `touch` just runs `addWindow` on passed-in window
  - `removeWindow` to get index of passed-in window and splice windows array if it's in the array
  - `getLastFocusedWindow` to find windows with passed-in `predicate` (or all windows if no predicate)
  - `all` to return the windows array

## application-menu.js
- instantiated within `AtomApplication` constructor
  - see `atom-application.js` notes above
- includes `app` and `Menu` from `electron`
- includes `MenuHelpers` from `src/menu-helpers`
- comment explains it's global menu management for adding, removing, maintaining menu items
- the body of the file exports the `ApplicationMenu` class
  - constructor focuses on assignment and one autoupdate listener
    - take a version and `autoUpdateManager` and assigns both
    - create a `WeakMap` and assigns to `this.windowTemplates`
    - set the active template to default
    - listener for auto update state change to show update menu item
  - `update` to update the window menu and its keybindings
    - take browser window, menu template to display, keystroke commands object
    - run `this.translateTemplate` to set keystrokes for the menu template items
    - run `this.substituteVersion` to update template version
    - set the window template to passed-in template
    - if the window is the last focused window, return `setActiveTemplate` with this template
  - `setActiveTemplate` to build and set the app menu from passed-in template
    - check if the active template is not the passed-in template
      - if not, set it to the active template and build and assign `this.menu`
      - use `Menu.buildFromTemplate` and `Menu.setApplicationMenu` to do menu work
    - either way return showing autoupdater items
  - `addWindow` to set passed-in window listeners and `enableWindowSpecificItems`
    - set window to last focused if none was already focused
    - build a focus handler for setting to last focused and template setup
    - add a window focus listener callback
    - add a close listener to delete the window and remove focus listener
    - run `this.enableWindowSpecificItems`
  - `flattenMenu` to get an unnested array of all menu items
    - iterate through items in passed-in `menu` object
    - add each item to array
    - recursively flatten and add any submenu object items to the end of the array
  - `flattenMenuTemplate` to take template items and flatten them into an array
    - works like `flattenMenu` except without assigning menu items to local const
  - `enableWindowSpecificItems` to enable all items that have metadata in flattened `this.menu`
  - `substituteVersion` to flatten template, find the item with version label, then update item label value
  - `showUpdateMenuItem` to set visibility for various update items on the menu
    - first flatten menu items
    - then get ones with labels for check, checking, downloading, restart/install
    - return if none found
    - turn off visibility of each, then switch case using passed-in `state` to display one
  - `getDefaultTemplate` to return an Atom menu template
    - takes no arguments
    - only statement is a returned array with one object
    - array has two properties: an Atom label and an array of submenu objects
    - each submenu entry has a `label`, `accelerator` keybinding and `click` callback
      - entries to check updates, reload, close window, toggle dev tools, quit
      - callbacks run basic window or app methods
      - check for update just has `metadata` to enable autoupdate
  - `focusedWindow` to find the focused window
    - use global AtomApplication instance to get all windows and find one with `window.isFocused()`
  - `translateTemplate` to iterate through template and assign accelerator keystroke commands
    - take a template and keystrokes-commands object
    - iterate through each template item and assign accelerator and click
      - set `item.accelerator` to `this.acceleratorForCommand`
      - set `item.click` to run the result of global Atom app instance `sendCommand` with the item command
    - iterate through any submenus and recursively call to assign submenu accelerators and clicks
    - return the template now with keybindings and commands
  - `acceleratorForCommand` to build the Electron-readable keystroke string
    - return the result of `MenuHelpers.acceleratorForKeystroke` with the keystroke for this command

## atom-window.js
- this window class gets included in main application source described above
- include browser window, app dialog and main IPC events from Electron
- include filesystem, url, path and event emitter modules
- before creating the class assign a few variables
  - resolved path to icon
  - updatable shell load boolean and `nextId` int
- the rest scripts the main `AtomWindow` class built atop `EventEmitter`
  - constructor assigns properties for settings, app and file recovery
    - increment and assign `nextId` to `this.id`
    - store file recovery service
    - store settings spec, headless, modes, resource path
    - use settings to determine path to open and locations to open
    - assign promises for loaded and closed async work
  - constructor then builds an Atom window options object
    - title `Atom`, tabbing id `'atom'`
    - background throttling and blink features settings
  - constructor then instantiates a browser window and binds it locally
    - set and pass in title bar options
  - constructor then assigns load settings and does work to store load paths
    - use event to get load settings JSON and run `handleEvents` method below
    - load settings for resource path, Atom home, modes, version, clear window state
    - build and sort an array of initial paths from locations to open
    - use shell load boolean from top of script to send only to first non-spec window
  - constructor then attaches some browser window listeners
    - window loaded event to disable zoom, emit window loaded and resolve loaded promise
    - window locations opened event just to emit that event
    - enter or exit full screen event to send full screen to browser
  - constructor finally sets up window and opens location if available
    - have browser window load resource path index as URL
    - attach `showSaveDialog` method below to browser window
    - determine if there are any locations to open
    - (locations to open pulled out of passed-in settings near start of constructor)
    - if this isn't a spec window and there are paths, run `openLocations` method below
  - `hasProjectPath` to check if there's at least one represented directory path
  - `setupContextMenu` to include the `context-menu` and instantiate one on browser window event
  - `containsPaths` to check `containsPath` on every path in an array
  - `containsPath` to check if some represented directory paths match the passed-in path
  - `handleEvents` to attach a bunch of browser window `on` listeners
    - `close` listener to async save and close window
    - `closed` listener to notify file recovery service of close, remove window from app and resolve closed promise
    - `unresponsive` listener to create force close or wait dialog for non-spec window
    - web contents `crashed` to async exit if headless or fs crash and close/reload dialog otherwise
    - web contents `will-navigate` to prevent default if event URL doesn't match content URL
    - run `setupContextMenu`
    - `focus` spec window on `blur` event to make sure it stays in focus
  - `prepareToUnload` to async create and return a promise with unload prep work
    - create `lastPrepareToUnloadPromise`
      - assign a callback that removes `ipcMain` listener and resolves if event sender is browser window
      - add `ipcMain` listener with that callback
      - send prepare to unload event
    - return that promise
  - `openPath` to run `this.openLocations` with passed-in path, line and column
  - `openLocations` to wait for load then send open locations event with locations to open
  - `didChangeUserSettings` to send user settings changed message with passed-in settings
  - `didFailToReadUserSettings` to send failure to read message with passed-in message
  - `replaceEnvironment` to send environment to browser window web contents
  - `sendMessage` to send message to browser window web contents
  - `sendCommand` to run spec commands or send commands to browser window
    - spec window commands not sent to app first responder can reload, toggle dev tools, close
    - non-spec commands are sent to browser window if window is web view focused or app cannot send to first responder
      - see `sendCommandToBrowserWindow` below
  - `sendURIMessage` to send browser window contents message with passed-in uri
  - `sendCommandToBrowserWindow` to send browser window contents a passed-in command and args
    - assign an action `context-command` if that's the first arg otherwise `command`
    - pass the browser window web contents `send` the action, command and spread args
  - `getDimensions` to build an object with browser window dimensions
    - store the x and y positions
    - store the width and height
    - return an object with the x and y positions, width and height
  - `shouldAddCustomTitleBar` to set non-spec Mac app config title bar to `custom`
  - `shouldAddCustomInsetTitleBar` to do the same as above but set it to `custom-inset`
  - `shouldHideTitleBar` to to the same as above but set it to `hidden`
  - `close` to run browser window close method
  - `focus` to run browser window focus method
  - `minimize` to run browser window minimize method
  - `maximize` to run browser window maximize method
  - `unmaximize` to run browser window unmaximize method
  - `restore` to run browser window restore method
  - `setFullScreen` to run browser window fullscreen method using passed-in `fullScreen`
  - `setAutoHideMenuBar` to run browser window auto hide menu bar
  - similar pass-through methods for checking if browser window focused, maximized, minimized, spec, web view focusedWindow
  - `handlesAtomCommands` to check if this isn't a spec window and isn't web view focused
  - `reload` to unload then reload
    - assign a new loaded promise
    - run `prepareToUnload` and chain work to reload browser window
    - return loaded promise
  - `showSaveDialog` to create save file dialog options object and run dialog
    - options are just save text and default path
    - run async `dialog.showSaveDialog` if callback function passed otherwise sync return it
  - `toggleDevTools` to run browser window toggle dev tools method
  - `openDevTools` to run browser window open dev tools method
  - `closeDevTools` to do the same but with close method
  - `setDocumentEdited` is another browser window pass-through method but with document argument
  - `setRepresentedFilename` is another one and takes a filename argument
  - `setRepresentedDirectoryPaths` to sort passed-in paths, set load settings paths and save atom app window options
  - `didClosePathWithWaitSession` to pass window and path to Atom app to run method
  - `copy` to run browser window copy method
  - `disableZoom` to set browser window web contents visual zoom limits to 1, 1

## atom-protocol-handler.js
- created when Atom app instantiated (see `atom-application`)
- handle loading URLs with custom protocol handler `atom://`
- imports Electron `protocol` plus filesystem and path stuff
- exports `AtomProtocolHandler` class with the behavior described below
- constructor builds and stores load paths and registers the protocol
  - take args for resource path and safe mode flag
  - load paths include dev packages and resource path packages outside of safe mode
  - load paths include core packages and resource path node modules
  - run `this.registerAtomProtocol`
- `registerAtomProtocol` to create the custom handler
  - spend the entire body of the function calling `protocol.registerFileProtocol`
  - pass the first argument `'atom'`
  - define the callback argument taking back a `(request, callback)`, then:
    - normalize the `request.url`
    - build a filepath from the normalized URL and Atom home path or load path
    - run the `callback` passing in that filepath

## parse-command-line.js
- imported and used in `start.js`
- requires dedent, yargs and the `app` export from Electron
- exports a `parseCommandLine` function taking a `processArgs` argument
  - set up args options
  - set the `options.usage` to a helpful message about paths and environment variables
  - set and describe options booleans, strings and aliases for arguments
  - go through the `options.argv` to assign variables based on args
  - return an object with twenty assigned arg variables incl paths, modes, timeout, ...

## squirrel-update.js
- run Win setup and update for the app
- import filesystem, path, spawner (script in this same directory), win and folder and name stuff
- define spawn `setx.exe` from `./System32` if running from root otherwise just relative
  - pass through args and callback when it's finished
- define spawn `update.exe`
  - pass through args and callback when it's done
- `addCommandsToPath` to add Atom and APM paths to Atom `bin/` folder
  - do this for `atom.cmd`, `atom`, `apm.cmd`, `apm` to add "`.cmd` shims"
  - write to each of the bin files then run passed-in callback
- `addBinToPath` to run `setx.exe` method with bin path segments and passed-in callback
- `installCommands` to get Win PowerShell path, split path, add `bin/` if needed and run callback
- `removeCommandsFromPath` to get path without `bin/` and run `setx.exe` method if new path
- `createShortcuts` to run command line statement to create desktop and start menu shortcuts
- `updateShortcuts` to make shortcut path from home, add to desktop if not previously deleted
- `removeShortcuts` to run command line statement to remove desktop and start menu shortcuts
- assign export the defined `update.exe` spawn as `exports.spawn`
- `exports.existsSync` to check if the `update.exe` was installed with Atom (if exists sync)
- `exports.restartAtom` to set a `will-quit` listener and quit the app
  - check if global Atom app exists and last focused window
    - if so, destructure project path and assign it as args
  - add an `app.once` listener to run `Spawner.spawn` with the bin `atom.cmd` path and args
  - run `app.quit`
- `updateContextMenus` to run Win Shell file and folder update methods, then passed-in callback
- `exports.handleStartupEvents` to handle special `squirrel` commands with switch-case
  - if squirrel install arg, create shortcuts, `addCommandsToPath`, run Win Shell file handler register, update menus and quit
  - if updated arg, do all the same except update shortcuts, Win Shell update
  - if uninstall arg, `removeCommandsFromPath`, four Win Shell deregister methods, app quit
  - if obsolete, just run app quit
  - in all cases except default, return `true`

## spawner.js
- import `child_process`
- export a `spawn` function
  - take a command plus args and a callback
    - comments say the command is the underlying OS command to execute
    - comments say the callback is invoked with error (with a `{code, stdout}`) and stdout
  - attempt to use `ChildProcess.spawn` to run the command and output errors to `stdout`
    - assign it to `SpawnedProcess`
  - attach data listener to `SpawnedProcess` to concatenate data onto `stdout`
  - attach error listener to it to remember process error
  - attach close listener to it to deal with errors and run callback
    - the event gets a `code` and a `signal`
    - assign a command failed error if there's not one but the code is not `0`
    - if there's an error but no error code or error stdout, assign them
    - run the callback with the error and stdout
  - end stdin ("necessary if using Powershell 2 on Windows 7")

## Windows scripts in main-process
- `win-powershell` script deals with .Net Powershell spawning, args, path,
- `win-shell` script deals with registration
- see `spawner` and `squirrel-update` for supporting scripts

## file-recovery-service.js
- still in `src/main-process`
- imports Electron dialog object, crypto, path, filesystem and recursive `mkdirp`
- exports a file recovery service and a recovery file
- `FileRecoveryService` class
  - constructor takes and assigns a recovery directory
  - constructor instantiates maps for windows by recovery file, files by path
  - constructor instantates a weak map for files by window
    - recall that `WeakMap` uses weak (GC-susceptible) Object-only keys
  - async `willSavePath` to get or create a recovery file for this path, then add window and file to maps
    - take a window and a path
    - get the file at this path from files by path map, or create a new `RecoveryFile`
    - add the recovery file to the files by window map at passed-in window key
    - add the window to windows by file map at the recovery file key
    - add the path, recovery file pair to recovery files by path map
  - async `didSavePath` to get the recovery file for this window, path and delete from maps
  - async `didCrashWindow` to create and resolve array of recovery promises for window
    - take a window
    - iterate through recovery files for this window, adding promises to array
    - in each promise show dialog on error, otherwise delete recovery file data from maps
    - use `Promise.all` to resolve all of the promises
  - `didCloseWindow` to delete passed-in window for recovery files and in windows by files
- `RecoveryFile` class
  - static `fileNameForPath` method to parse and create a filename for the passed-in path
  - constructor takes path, file mode, recovery path and binds them to the instance
    - also add an instance ref counter
  - async `store` to run `copyFile` with instance variables above
  - async `recover` to run `copyFile`with instance variables and then `remove`
  - async `remove` to return promise running filesystem unlink on the recovery path
  - async `retain` to run `store` if `isReleased` and increment the instance ref counter
  - async `release` to decrement ref counter and run `remove` if `isReleased`
  - `isReleased` to check if instance ref counter is `0`
  - async `tryStatFile` to run filesystem stat on passed-in path
  - async `copyFile` to return promise with filesystem work to write source file to destination file
    - take source, destination and mode args
    - inside the promise run `mkdirp` passing destination path and callback
    - in the callback open a filesystem readstream
    - once opened create a writestream
    - on writestream open pipe readstream to writestream
    - once writestream closed resolve the promise

## auto-update-manager.js
- used in `atom-application` and in `application-menu` (which is also included in Atom app)
- imports event emitter, path
- declares some global strings for a variety of states including idle, error, checking, downloading
- sets a void `autoUpdater`
- exports an `AutoUpdateManager` class inheriting from `EventEmitter`
  - constructor takes in a version, test mode, config
  - constructor binds a bunch of variables including passed-in, idle state, icon path
  - `initialize` to set API update feed URL and attach `autoUpdater` events
    - set the `autoUpdater` to either `auto-updater-win32.js` export or get it from Electron
    - run `setFeedURL` on the built feed path with version number appended to URL path
    - on error event, `setState` to error and `emitWindowEvent` for error
    - on checking for update event, set state and emit window event for checking
    - on update not available event, set state and emit window event
    - on update available event, set state and emit window event and emit event
    - on update downloaded event, change version and set state and emit update available event
    - config on change event, run `scheduleUpdateCheck` if `newValue` otherwise `cancelScheduledUpdateCheck`
    - if config `core.automaticallyUpdate` then run `scheduleUpdateCheck`
    - set state to unsupported for linux or conditionally win32
  - `emitUpdateAvailableEvent` to run `emitWindowEvent` if there's a release version
  - `emitWinodwEvent` to send message with passed-in event and payload to each Atom window
  - `setState` to assign state, error message variables and `emit` state changed event passing state
  - `getState` to return `this.state`
  - `getErrorMessage` to return `this.errorMessage`
  - `scheduleUpdateCheck` to set a periodic update check
  - `cancelScheduledUpdateCheck` to void out any `checkForUpdatesIntervalID`
  - `check` to add once events for update not available and error, then `checkForUpdates`
    - do not check in test mode
  - `install` to run `quitAndInstall` if not in test mode
  - `onUpdateNotAvailable` to remove error listener and show update unavailable dialog
  - `onUpdateError` to remove update not available listener and show update error dialog
  - `getWindows` to run global Atom app `getAllWindows`

## context-menu.js
- see main Atom Application including `setupContextMenu` method
- imports Electron Menu
- exports a `ContextMenu` class
  - constructor takes a template and Atom Window
  - constructor binds Atom Window locally
  - constructor runs `createClickHandlers` with the template
  - constructor builds menu from template and runs Electron `menu.popup`
  - `createClickHandlers` to add Atom Window and send command to window for each template item
    - comments note this method keeps closures from being "dragged across processes" and allows proper GC
    - take passed-in template
    - iterate through template items
    - attach instance Atom Window to item command detail Atom Window
    - add a click event handler that sends item command and window to Atom app
    - recursively run `createClickHandlers` if submenu in item


## Supporting Projects & Concepts

### Socket Files
- work in the Atom app
  - socket path is added to `options` object passed to static `open`
  - create path name including first 12 chars of a hashed instance digest
    - outside of win32 this starts with `os.tmpdir()`
  - empty socket path sometimes takes a while to throw error (commented "FIXME")
  - `constructor` binds the socket path
  - socket path then used for app server listening, deleting, and restarting
- looking up "socket file" (starting [on Wikipedia](https://en.wikipedia.org/wiki/Unix_file_types#Socket))
  - sockets are used to communicate between processes
  - use `sendmsg` or `recvmsg` for data or [I/O descriptors](https://en.wikipedia.org/wiki/File_descriptor) (0, 1 or 2)
  - two-way data flow, unlike one-way "named pipes"
  - mode string marks socket files with `s` at beginning
- browsing around with terminal
  - open Atom app
  - look through files in root `.atom`
  - actually `echo $TMPDIR` to see OS temp (MacOs `(/private)/var/folders/ ... `)
  - navigate to dir and find `atom-{hash12}.sock`: `cd $TMPDIR`
    - Atom crashes and APM install dir also live here
  - the file looks empty to me
  - the file does not exist after closing Atom
  - the file exists again, with same hash, on Atom start
  - opening with `less` I get a message that it `is not a regular file (use -f to see it)`
    - but even after adding that option: `Operation not supported on socket`
  - opening with other text editors the file is empty
  - `ls -l` shows the socket file size `0` and the "socket" at beginning of permission string: `srwxr-xr-x`

### Electron
- see questions above
- here broken down roughly by how imported in `atom/atom`

#### Electron Main
- [Electron](https://github.com/electron/electron)
  - what I've heard: Electron is for writing JS apps you can run from your machine just like JS does in a browser
  - from the repo: it's a desktop  JS+HTML+CSS app building platform based on Node and Chromium
    - this would be a whole separate set of notes, so keep this brief for now
  - Electron is written in C++ with quite a bit of JS, some Objective-C++, a dash of Python, ...
  - `/default_app/` starts in `main.js` but even that imports `app` from `electron`
  - from the `package.json` it looks like `/script/` specifically `/script/start.js` is an entry point
    - that just gets us toward utils, processes, path, args, patch stuff
  - ah, is `app` the one in `/lib/browser/api/app.js`?
    - this file imports an `app` from `bindings`
    - this one imports just `electron` and Electron menu and `deprecate`
    - this one exports `app`
    - assign app menu methods and command line arg methods to `app` object
    - add app metrics method and `isPackaged` check (for if there's not already an executable)
    - add dock (Mac) or launcher (Linux) properties
    - add domain credentials whitelisting and web contents event routing
  - TODO: spend more time (than just this <1h) looking through the scripts

#### Electron IPC (imported separately multiple times in Atom)
- IPC files (besides `spec` testing) live in `lib/browser/`
  - see `lib/browser/api` for a short script that exports an event emitter
  - [ipcMain API documentation](https://github.com/electron/electron/blob/master/docs/api/ipc-main.md) is under `/docs`
- documentation above describes exported module as `EventEmitter` instance
- use for async and sync messaging between main and render processes
  - mainly from render process (web page) to the module, onto the app
  - also send messages back to render process (keep reading below)
- send messages to render process with `webContents.send`
  - event name `channel`
  - reply to sync messages with `event.returnValue`
  - send async messages back with `event.sender.send`
  - read [this example](https://github.com/electron/electron/blob/master/docs/api/ipc-main.md#sending-messages) of ping-ponging messages between the processes
- `ipcMain` has `on`, `once`, `removeListener` and `removeAllListeners` methods
  - all take a `channel` event string
  - all but `removeAllListeners` take a listener function to run/remove
- `ipcMain` callbacks pass an `event` arg to the callback
  - `event.returnValue` will be returned in a sync message
  - `event.sender` has sender's `webContents` and can `.send` to async reply
- `ipc-helpers` script lives in Atom (_not_ Electron) right there within `src/`
  - wrap and export an `on` method taking an emitter, event, callback
    - attach an `emmiter.on` listener
    - and return a `removeListener` Disposable
  - export a `call` method
    - import `ipcRenderer` from Electron (what is this? - below)
    - set renderer max listeners to `20`
    - return promise to create rendered `on` listener removing listeners and sending event, args
  - export a `respondTo` to import and assign `ipcMain` instance and return an `on` listener
    - take a `channel` (event) and a `callback` (method to run)
    - and really return an exported `on` method call
    - call `on` with `ipcMain`, event, and an async function call with event, response event, args spread
    - async func assigns browser window web contents event sender to `browserWindow`
    - async func waits for response from calling `callback` on browser window and args spread
    - async func runs async message `event.sender.send` with response event and the result of calling that callback
  - `ipc-renderer` in `/lib/renderer/api`
    - documentation in `/docs/api/`
      - another `EventEmitter` instance
      - methods for sync and async messaging (also replying) from web page to main process
      - roughly, how the browser window page can communicate with the app
    - get and assign global `v8_util` hidden value `ipc` as `ipcRenderer`
    - assign a process `ipc` Atom Binding to `binding`
    - create a boolean `internal` and set `false`
    - wrap methods with `ipcRenderer`
      - `send` to run and return `binding.send` with `ipc-message` event and passed-in args
      - `sendSync` to return zeroth result of running `binding.sendSync` with `ipc-message-sync` event and passed-in args
      - `sendToHost` to return call to `binding.send` with `ipc-host-message` event and passed-in args
      - `sendTo` to return call to `binding.sendTo` with passed-in `webContentsId`, event and args
        - pass `internal` and `false` in the first two params
      - `sendToAll` to return call to `sendTo` as above but passing `true` in second param
    - export `ipcRenderer`

### atom/event-kit
- "event subscription APIs"
- see Atom imports in for example `src/main-process/atom-application` and `src/ipc-helpers`
- peel off two main parts: `Emitter` for implementing events, `Disposable` for consuming
  - in short: _subscribing_ vs _unsubscribing_
  - emitter `on` listeners return disposables; call `dispose` to use
  - `CompositeDisposable` puts disposables together (unsubscribe from multiple)
  - `Disposable` allows creating disposables passing your own function for work
- `lib/event-kit` exports emitter, disposable and composite disposable classes
- `lib/composite-disposable`
  - constructor assigns `disposed` to `false` and creates disposables set
  - `dispose` to switch on `disposed` and run `dispose` on each disposable in set
  - `add` to `assertDisposable` on and add disposable to disposables set
  - `remove` to delete from disposables set
  - `delete` alias for `remove`
  - `clear` to clear out disposables set (not disposed by next `dispose` call)
  - `assertDisposable` to check if disposable has a `dispose` method
- `lib/disposable`
  - disposable resource returned by emitter `on`
  - static `isDisposable` to check if passed-in object has a `dispose` function
  - constructor to set `disposed` to `false` and bind passed-in `disposalAction` function
  - `dispose` to switch on `disposed` and run `disposalAction` function
- `lib/emitter`
  - import disposable and composite disposable
  - static `onEventHandlerException` to add exception handler to handlers array and return disposable for removing handler
  - static `simpleDispatch` to return the result of running passed-in handler with passed-in value
  - static `exceptionHandlingDispatch` to run handler with value and catch and run exception handler
  - constructor assigns switched-off `dispose` and runs `clear`
  - `clear` to run `dispose` on existing subscriptions, instantiate new `subscriptions` composite disposable, and emtpy object storing `handlersByEventName`
  - `dispose` to run `dispose` on `subscriptions` and switch on `dispose` boolean
  - `on` to add handler to handlers by event name and return disposable
    - takes an event name, handler and an unshift (for positioning in array)
    - disposable work removes this disposable from `subscriptions` and returns running `off` with this event name and handler
  - `once` to run `on` passing a callback that disposes disposable and runs handler
    - takes an event name, handler and an unshift
  - `preempt` to return running `on` with passed-in event, handler and unshift to `true`
  - `off` to remove handler from handlers array at this event name
  - `emit` to dispatch handlers (in `handlersByEventName`) using passed-in value for passed-in event
  - `emitAsync` to wrap dispatches in promise
  - `getEventNames` to return all keys in `handlersByEventName`
  - `listenerCountForEventName` to get length of handlers array for passed-in name
  - `getTotalListenerCount` to sum all handlers in `handlersByEventName`
