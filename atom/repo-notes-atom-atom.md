# Repo notes: atom/atom

## Overview
- README checks the basic boxes but lacks any path into the code base
  - test shields
  - mentions and links to Electron
  - product description, including links to community and code of conduct
  - links to documentation: Flight Manual and API Reference (see my notes)
  - installation prerequisites and OS steps
  - links to building instructions
  - license
- how to know the code?
  - existing docs don't directly answer that question
- goals of this doc:
  - break down and understand the codebase from a wide view
  - trace a beginning path through the code to gain that understanding

## Basic Branching
- `apm` for Atom Package Manager
  - just an install folder for APM: https://github.com/atom/apm
  - most use cases covered by APM command line tool
  - API info: https://atom.io/docs/api/v1.29.0/PackageManager
  - Flight Manual: https://flight-manual.atom.io/atom-server-side-apis/sections/atom-package-server-api/
  - an [example of how Atom uses apm](https://github.com/atom/settings-view/blob/master/lib/package-manager.coffee)
- `benchmark` for a benchmark runner and large file / long line tests
- `docs` for building documentation
  - focused on platform-specific instructions for building Atom from source
  - this was moved to the Flight Manual
  - `./focus` contains a doc [sharing current plans](https://github.com/atom/atom/tree/master/docs/focus)
- `dot-atom` contains the files and directories that install to `.atom`
  - including the custom stylesheet and keymap files
  - including the custom packages directory
- `exports` requires and exports objects
  - requires and exports a bunch of src objects that all seem to deal with file and buffer load/events
    - including Task and TextEditor when not a child node process (meaning when process type is `'renderer'`)
  - also contains a handful of Electron API shims using [grim.deprecate](https://github.com/atom/grim/blob/master/src/grim.coffee)
- `keymaps`
  - cson keybinding maps for various platforms
  - `base.cson` has selectors for `atom-text-editor` and many `body` default to native
  - movement, selection and many other bindings for `darwin`, `linux`, `win32`
- `menus`
  - three files containing array of menu items for different platforms
  - objects contain a `label` and `submenu` arrays of objects with `label` and `command`
- `resources`
  - png app icons
  - shell script, js and apm shell and command scripts for `win` installation
  - long bundle info plist for `mac`
  - debian and redhat package for `linux`
- `script`
  - a variety of scripts for building Atom
  - linter scripts
  - version and platform sensitive installation, cleaning, transpiling
  - `vsts` subfolder
    - contains its own README
    - scripts for automating Atom releases
    - `yml` files for configuring releases
    - tasks for handling release branch on different platforms
    - uses Visual Studio Team Services
      - [multi-phase jobs](https://github.com/Microsoft/vsts-agent/blob/master/docs/preview/yamlgettingstarted-jobs.md)
      - generate Atom installation packages on all three platforms
      - publish new release on successful build
    - Atom Nightly packages published to GitHub and atom.io
    - version release numbers calculated by `generate-version.js`
      - nightly release number incremented after comparing base version against `package.json`
    - phase templates build Atom simultaneously across platforms
    - successful build release artifacts uploaded to S3 bucket
- `spec`
  - quite a large directory with many CoffeeScript and JS `-spec` files
  - Jasmine `describe` tests
    - run for Atom environment, paths, clipboard, installation, grammar registry, style manager and much more
    - the project settings `config` spec is a long, representative example: https://github.com/atom/atom/blob/master/spec/config-spec.js
  - `./helpers` directory contains a random line builder and a very long lexicon
  - `./fixtures` contains samples with extreme formatting, example packages, sample themes
  - `./main-process` contains the application test and command line test
- `src`
  - `./main-process` subdirectory contains application start, menu, win updater and more
    - the short `main.js` is where the start path is built
    - `parse-command-line.js` breaks down cli args and returns object with all the process info
    - `start.js` is called from `main`
      - runs the command line parser and stores the resulting `args`
      - sets up `app.on` events for opening files, launching and ready
      - requires `./main-process/atom-application` and runs `.open` with `args`
      - defines a `getConfig` function to read the config file
  - the rest of the directory is many `.js` and `.coffee` files
    - class exports for many of the objects documented in the API
      - for example, [Package](https://atom.io/docs/api/v1.29.0/Package) relates to `package.js`
      - that example defines `onDidDeactivate (callback) { ... }` mentioned in the API docs
      - others include everything from `gutter` to `pane` to `cursor` to global `config-file`
    - `grammar-registry` is an example with many requires, complex class methods, much to think through
    - some API doc classes come from other sources imported into these `src` files
      - like `Emitter` from `event-kit`
        - for example, the `package.js` mentioned above requires and instantiates `Emitter`, then `onDidDeactivate` returns `emitter.on()` event with your callback
      - or like `Disposable` and `CompositeDisposable` from `event-kit`
    - some scripts provide other functionality
      - like how `crash-reporter-start` requires and starts CrashReporter from `electron`
      - or how `babel` creates a babel version and compiles source using babel
- `static`
  - `.less` files for editor, cursors, docks, syntax and much more
  - stylesheet fallback variables
  - basic html template `index.html`
  - window load and setup script in `index.js`
  - and the octocat spinner!
- `vendor`
  - Jasmine tests for JS and JQuery
  - on second glance, these are not tests but the testing framework
  - see tests under `spec`
- root files
  - `.gitattributes` for defining line endings on `spec/fixtures` files
  - support/appinfo files for appveyer, coffeelinter, Python versioning, style linter, Docker
  - package and package locks for node
  - Travis config yaml file
  - `LICENSE` copyrights software to GitHub, permissively allowing as-is use
  - user submission templates
    - `ISSUE_TEMPLATE` defines checklist and format to use when submitting an issue
    - `PULL_REQUEST_TEMPLATE` defines requirements and needed info when submitting a PR
  - `CHANGELOG` links to [Atom releases](https://atom.io/releases)
  - `README` and `SUPPORT` provide documentation for getting into Atom
    - the readme focuses on installation
    - the support doc focuses on links into the documentation and community
  - `CODE_OF_CONDUCT` adapts the OSS [Contributor Covenant](https://www.contributor-covenant.org/)
  - `CONTRIBUTING` offers a detailed set of guidelines for contributing to Atom

## CONTRIBUTING.md in greater detail
- since the focus of my repo is on contributing, I'll outline this in detail
- Atom as part of the [Atom Organization](https://github.com/atom)
- contributor covenant as mentioned above
- issues are a [deluge](https://blog.atom.io/2016/04/19/managing-the-deluge-of-atom-issues.html) and are not for questions
- discussions happen at [discuss](https://discuss.atom.io/), which has a FAQ[FAQ](https://discuss.atom.io/c/faq)
- faster discussion happens in the [team chat](https://atom-slack.herokuapp.com/)
  - use the appropriate channel: `#atom`, `#electron`, `#packages`, `ui`
- background knowledge
  - Atom has over 200 repos, so know which implements which functionality
  - this helps so you know where to report bugs
  - modularity by intention
    - non-editor UI is almost always a separate package
    - even tree-view, find-and-replace, tabs and status-bar are packages
    - key difference: whether a package is bundled into default distribution
  - visit `Settings` and view `Packages` to see Core packages
    - Atom Core: `atom/atom`
      - text editor
      - associated functionality like indentation, wrapping, rendering, file system, installation and updating
      - this repo is good for giving feedback on API or proposing "overarching" features
    - stuff around the UI
      - like `tree-view`, `fuzzy-finder` (quick file opener), `find-and-replace`, `tabs`, `markdown-preview`, `settings-view`, ...
    - stuff around behavior and styling
      - like autocomplete, git, default UI and syntax themes
    - Atom Package Manager: `apm`
    - Feedback repo for website and `apm`'s package API: `atom.io`
  - note that issues arise from [community pacakges and themes](https://discuss.atom.io/t/i-have-a-question-about-a-specific-atom-community-package-where-is-the-best-place-to-ask-it/25581)
  - package naming conventions
    - syntax highlighting grammars: `language-[language-name]`
      - these can add more than grammars but shouldn't get too bulky
    - UI themes: `[theme-name]-ui`
      - these style stuff outside editor pane
    - syntax themes: `[theme-name]-syntax`
      - these style stuff inside editor pane
      - (me: wow, that's an easy distinction I wish the Flight Manual made)
    - coordinate themes that do both, like `one-dark-ui` and `one-dark-syntax`
    - atocomplete providers: `autocomplete-[autocompleted]`
      - an example might be `autocomplete-css`
- design decisions
  - commitment to maintain a [decisions repo](https://github.com/atom/design-decisions)
  - this will include big decisions about how Atom is maintained and what can be supported
  - if decisions are not documented there, check the "discuss" link above
